// Prisma Schema for 좋아하면 울리는

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 사용자 테이블
model User {
  id              String    @id @default(uuid())
  tossUserId      String    @unique // 토스 계정 고유 ID
  name            String?            // 토스 로그인에서 받은 사용자 이름 (필수 동의)
  gender          String?            // 성별 (선택 동의) - male/female
  birthday        DateTime?          // 생년월일 (선택 동의)
  instagramId     String?            // 인스타그램 ID (중복 허용 - 실제 인증은 OAuth로)
  maxSlots        Int       @default(2) // 최대 알람 슬롯 수 (기본 2개, 결제로 증가)
  pushEnabled     Boolean   @default(false) // 푸시 알림 허용 여부
  tossAppEnabled  Boolean   @default(false) // 토스 앱 알림 허용 여부
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  alarms       Alarm[]    @relation("UserAlarms")      // 내가 등록한 알람들
  matchesAsUser1 Match[]  @relation("MatchUser1")
  matchesAsUser2 Match[]  @relation("MatchUser2")
  feedbacks    Feedback[]                              // 내가 보낸 피드백들
}

// 알람 (좋아요) 테이블
model Alarm {
  id                 String    @id @default(uuid())
  userId             String                          // 알람을 등록한 사용자
  fromInstagramId    String                          // 본인 인스타그램 ID (알람별로 다를 수 있음)
  targetInstagramId  String                          // 대상의 인스타그램 ID
  status             String    @default("waiting")   // waiting | matched
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  deletedAt          DateTime?                       // Soft Delete용 (null = 활성, 값 있으면 = 삭제됨)

  // Relations
  user               User     @relation("UserAlarms", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, targetInstagramId]) // 같은 대상에게 중복 알람 방지
}

// 매칭 테이블
model Match {
  id        String   @id @default(uuid())
  user1Id   String
  user2Id   String
  matchedAt DateTime @default(now())

  // Relations
  user1     User     @relation("MatchUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2     User     @relation("MatchUser2", fields: [user2Id], references: [id], onDelete: Cascade)

  @@unique([user1Id, user2Id]) // 같은 매칭 중복 방지
}

// 피드백 테이블
model Feedback {
  id        String   @id @default(uuid())
  userId    String?                         // 로그인한 사용자 ID (비로그인 시 null)
  category  String                          // 카테고리: 건의, 버그, 신고, 칭찬, 기타
  content   String                          // 피드백 내용
  status    String   @default("pending")    // pending | reviewed | resolved
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
}

